<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>knemap_functions API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>knemap_functions</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd




def update_dataframe_indexes(df, mapping):
    &#39;&#39;&#39;
    Updates the index of df with keys of mapping.

    Input

        df (DataFrame)

        mapping (dict): key needs to be same as index identifiers of data_genes, as loaded from file

    Output

        df (DataFrame)
    &#39;&#39;&#39;
    temp = df.index.tolist()
    new_indx = []
    for item in temp:
        if item in mapping.keys():
            new_indx.append(str(mapping[item]))
        else:
            new_indx.append(item)
        
    df.index = new_indx
    return df




def remove_unknown_genes(mapping, data_genes):
    
    &#39;&#39;&#39;
    Drops genes (row identifiers) from data_genes that are not in mapping
    
    Input

        mapping (dict): key needs to be same as index identifiers of data_genes, as loaded from file

        data_genes (dataFrame): as loaded from file, processed gene expression data. Indices need to be gene identifiers.
        
    Output

        data (dataFrame): only containing genes were data is known about
    &#39;&#39;&#39;
    
    #select all rows which data is known for
    print(&#34;original number of rows &#34;, len(data_genes))
    
    for gene in data_genes.index:
        if gene not in mapping.keys():
            data_genes = data_genes.drop(gene)
    
    print(&#34;number of known genes &#34;, len(data_genes))
    
    
    
    
    return data_genes

def select_genes(chemical_genes, top=100, bottom=100, sort_by=None):
    &#39;&#39;&#39;
    
    helper function of create_fingerprints()
    
    
    Input

        chemical_genes (DataFrame) with single colum, were index is gene names and colum FC for specific chemical

        top / bottom (int) specifiy x top &amp; bottom affect genes should be selected

        sort_by (str) is name of column dataFrame is sorted after (chemical name)
    
    Output

         df (dataFrame) with selected genes and FC values
    
    
    &#39;&#39;&#39;
    
    #sort dataframe after column values
    if sort_by is not None:
        sorted_frame = chemical_genes.sort_values(by=[sort_by], ascending=False)
        
        #select top and bottom rows to be returned
        top_frame = sorted_frame.head(top)
        bottom_frame = sorted_frame.tail(bottom)
        
        
        #merge back together into single frame
        return pd.concat([top_frame, bottom_frame], sort=True)
        
        
        
        
    else:
        print(&#34;please specify column name to sort by&#34;)
        return None
    
    
def get_partitioning_id(partitioning):
    &#39;&#39;&#39;
    helper function of create_fingerprints()

    Input

        partitioning (dict): communities, as loaded from file

    Output

        l (list)
    &#39;&#39;&#39;
    l = []
    
    for i in partitioning.values():
        if len(i) &gt; 0:
            if i[0] not in l:
                l.append(i[0])
        
            
    return l


def create_fingerprints(partitioning, df, top=100, bottom=100, add=&#34;&#34;):
    &#39;&#39;&#39;
    main mapping function to create exposure fingerprints via network mapping
    
    Input

        partitioning (dict): communities, as loaded from file

        df (dataFrame): exsposure data to select genes from. Each column needs to be an exposure, index needs to be same identifiers as partitioning values and individual genes will be ranked by values of each column.
        
        top (int): # of top ranked genes to be selected for each exposure
        
        bottom (int): # of bottom ranked genes to be selected for each exposure
        
        add (str): suffix to be added to column identifiers. This is needed if multiple exposures with same column names are compared
        
     Output

         fingerprint (dict): key is column identifier + suffix and value is fingerprint (list)
    &#39;&#39;&#39;
    fingerprint = {}
    
    #get ids of partitionings
    part = get_partitioning_id(partitioning)
    
    for c in df.columns:
        #print(c)
        temp = {}
        for i in part:
            temp[i] = 0
            
            
        #get top &amp; bottom gene for chemical c
        current = df[[c]]
        cur = select_genes(current, top=top, bottom=bottom, sort_by=c)
        
        #map genes to their communities
        for gene in cur.index:
            #get its community id
            if gene in partitioning.keys():
                com = partitioning[gene][0]
                #add to temp
                temp[com] = temp[com] + 1
            else:
                print(gene)
        #update temp to fraction
        for key in temp.keys():
            x = temp[key]
            temp[key] = x / (top+bottom)
            
        #print(temp)
        fingerprint[c+add] = temp
        
    return fingerprint


    
def sort_fingerprint_by_key(fingerprint):
    &#39;&#39;&#39;
    sorts the fingerprints by key so that if multiple data sets are compared, they can be in the same order
    
    Input

        fingerprint (dict): as returned by create_fingerprints()
        
    Output

        sorted fingerprint (dict): fingerprint sorted by key
    
    &#39;&#39;&#39;
    fingerprint_new = {}

    for k in fingerprint:
        fingerprint_new[k] = {}
        keylist = list(fingerprint[k].keys())
        keylist.sort()

        for key in keylist:
            fingerprint_new[k][key] = fingerprint[k][key]
            
            
    return fingerprint_new</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="knemap_functions.create_fingerprints"><code class="name flex">
<span>def <span class="ident">create_fingerprints</span></span>(<span>partitioning, df, top=100, bottom=100, add='')</span>
</code></dt>
<dd>
<div class="desc"><p>main mapping function to create exposure fingerprints via network mapping</p>
<p>Input</p>
<pre><code>partitioning (dict): communities, as loaded from file

df (dataFrame): exsposure data to select genes from. Each column needs to be an exposure, index needs to be same identifiers as partitioning values and individual genes will be ranked by values of each column.

top (int): # of top ranked genes to be selected for each exposure

bottom (int): # of bottom ranked genes to be selected for each exposure

add (str): suffix to be added to column identifiers. This is needed if multiple exposures with same column names are compared
</code></pre>
<p>Output</p>
<pre><code> fingerprint (dict): key is column identifier + suffix and value is fingerprint (list)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_fingerprints(partitioning, df, top=100, bottom=100, add=&#34;&#34;):
    &#39;&#39;&#39;
    main mapping function to create exposure fingerprints via network mapping
    
    Input

        partitioning (dict): communities, as loaded from file

        df (dataFrame): exsposure data to select genes from. Each column needs to be an exposure, index needs to be same identifiers as partitioning values and individual genes will be ranked by values of each column.
        
        top (int): # of top ranked genes to be selected for each exposure
        
        bottom (int): # of bottom ranked genes to be selected for each exposure
        
        add (str): suffix to be added to column identifiers. This is needed if multiple exposures with same column names are compared
        
     Output

         fingerprint (dict): key is column identifier + suffix and value is fingerprint (list)
    &#39;&#39;&#39;
    fingerprint = {}
    
    #get ids of partitionings
    part = get_partitioning_id(partitioning)
    
    for c in df.columns:
        #print(c)
        temp = {}
        for i in part:
            temp[i] = 0
            
            
        #get top &amp; bottom gene for chemical c
        current = df[[c]]
        cur = select_genes(current, top=top, bottom=bottom, sort_by=c)
        
        #map genes to their communities
        for gene in cur.index:
            #get its community id
            if gene in partitioning.keys():
                com = partitioning[gene][0]
                #add to temp
                temp[com] = temp[com] + 1
            else:
                print(gene)
        #update temp to fraction
        for key in temp.keys():
            x = temp[key]
            temp[key] = x / (top+bottom)
            
        #print(temp)
        fingerprint[c+add] = temp
        
    return fingerprint</code></pre>
</details>
</dd>
<dt id="knemap_functions.get_partitioning_id"><code class="name flex">
<span>def <span class="ident">get_partitioning_id</span></span>(<span>partitioning)</span>
</code></dt>
<dd>
<div class="desc"><p>helper function of create_fingerprints()</p>
<p>Input</p>
<pre><code>partitioning (dict): communities, as loaded from file
</code></pre>
<p>Output</p>
<pre><code>l (list)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partitioning_id(partitioning):
    &#39;&#39;&#39;
    helper function of create_fingerprints()

    Input

        partitioning (dict): communities, as loaded from file

    Output

        l (list)
    &#39;&#39;&#39;
    l = []
    
    for i in partitioning.values():
        if len(i) &gt; 0:
            if i[0] not in l:
                l.append(i[0])
        
            
    return l</code></pre>
</details>
</dd>
<dt id="knemap_functions.remove_unknown_genes"><code class="name flex">
<span>def <span class="ident">remove_unknown_genes</span></span>(<span>mapping, data_genes)</span>
</code></dt>
<dd>
<div class="desc"><p>Drops genes (row identifiers) from data_genes that are not in mapping</p>
<p>Input</p>
<pre><code>mapping (dict): key needs to be same as index identifiers of data_genes, as loaded from file

data_genes (dataFrame): as loaded from file, processed gene expression data. Indices need to be gene identifiers.
</code></pre>
<p>Output</p>
<pre><code>data (dataFrame): only containing genes were data is known about
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_unknown_genes(mapping, data_genes):
    
    &#39;&#39;&#39;
    Drops genes (row identifiers) from data_genes that are not in mapping
    
    Input

        mapping (dict): key needs to be same as index identifiers of data_genes, as loaded from file

        data_genes (dataFrame): as loaded from file, processed gene expression data. Indices need to be gene identifiers.
        
    Output

        data (dataFrame): only containing genes were data is known about
    &#39;&#39;&#39;
    
    #select all rows which data is known for
    print(&#34;original number of rows &#34;, len(data_genes))
    
    for gene in data_genes.index:
        if gene not in mapping.keys():
            data_genes = data_genes.drop(gene)
    
    print(&#34;number of known genes &#34;, len(data_genes))
    
    
    
    
    return data_genes</code></pre>
</details>
</dd>
<dt id="knemap_functions.select_genes"><code class="name flex">
<span>def <span class="ident">select_genes</span></span>(<span>chemical_genes, top=100, bottom=100, sort_by=None)</span>
</code></dt>
<dd>
<div class="desc"><p>helper function of create_fingerprints()</p>
<p>Input</p>
<pre><code>chemical_genes (DataFrame) with single colum, were index is gene names and colum FC for specific chemical

top / bottom (int) specifiy x top &amp; bottom affect genes should be selected

sort_by (str) is name of column dataFrame is sorted after (chemical name)
</code></pre>
<p>Output</p>
<pre><code> df (dataFrame) with selected genes and FC values
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_genes(chemical_genes, top=100, bottom=100, sort_by=None):
    &#39;&#39;&#39;
    
    helper function of create_fingerprints()
    
    
    Input

        chemical_genes (DataFrame) with single colum, were index is gene names and colum FC for specific chemical

        top / bottom (int) specifiy x top &amp; bottom affect genes should be selected

        sort_by (str) is name of column dataFrame is sorted after (chemical name)
    
    Output

         df (dataFrame) with selected genes and FC values
    
    
    &#39;&#39;&#39;
    
    #sort dataframe after column values
    if sort_by is not None:
        sorted_frame = chemical_genes.sort_values(by=[sort_by], ascending=False)
        
        #select top and bottom rows to be returned
        top_frame = sorted_frame.head(top)
        bottom_frame = sorted_frame.tail(bottom)
        
        
        #merge back together into single frame
        return pd.concat([top_frame, bottom_frame], sort=True)
        
        
        
        
    else:
        print(&#34;please specify column name to sort by&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="knemap_functions.sort_fingerprint_by_key"><code class="name flex">
<span>def <span class="ident">sort_fingerprint_by_key</span></span>(<span>fingerprint)</span>
</code></dt>
<dd>
<div class="desc"><p>sorts the fingerprints by key so that if multiple data sets are compared, they can be in the same order</p>
<p>Input</p>
<pre><code>fingerprint (dict): as returned by create_fingerprints()
</code></pre>
<p>Output</p>
<pre><code>sorted fingerprint (dict): fingerprint sorted by key
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_fingerprint_by_key(fingerprint):
    &#39;&#39;&#39;
    sorts the fingerprints by key so that if multiple data sets are compared, they can be in the same order
    
    Input

        fingerprint (dict): as returned by create_fingerprints()
        
    Output

        sorted fingerprint (dict): fingerprint sorted by key
    
    &#39;&#39;&#39;
    fingerprint_new = {}

    for k in fingerprint:
        fingerprint_new[k] = {}
        keylist = list(fingerprint[k].keys())
        keylist.sort()

        for key in keylist:
            fingerprint_new[k][key] = fingerprint[k][key]
            
            
    return fingerprint_new</code></pre>
</details>
</dd>
<dt id="knemap_functions.update_dataframe_indexes"><code class="name flex">
<span>def <span class="ident">update_dataframe_indexes</span></span>(<span>df, mapping)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the index of df with keys of mapping.</p>
<p>Input</p>
<pre><code>df (DataFrame)

mapping (dict): key needs to be same as index identifiers of data_genes, as loaded from file
</code></pre>
<p>Output</p>
<pre><code>df (DataFrame)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_dataframe_indexes(df, mapping):
    &#39;&#39;&#39;
    Updates the index of df with keys of mapping.

    Input

        df (DataFrame)

        mapping (dict): key needs to be same as index identifiers of data_genes, as loaded from file

    Output

        df (DataFrame)
    &#39;&#39;&#39;
    temp = df.index.tolist()
    new_indx = []
    for item in temp:
        if item in mapping.keys():
            new_indx.append(str(mapping[item]))
        else:
            new_indx.append(item)
        
    df.index = new_indx
    return df</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="knemap_functions.create_fingerprints" href="#knemap_functions.create_fingerprints">create_fingerprints</a></code></li>
<li><code><a title="knemap_functions.get_partitioning_id" href="#knemap_functions.get_partitioning_id">get_partitioning_id</a></code></li>
<li><code><a title="knemap_functions.remove_unknown_genes" href="#knemap_functions.remove_unknown_genes">remove_unknown_genes</a></code></li>
<li><code><a title="knemap_functions.select_genes" href="#knemap_functions.select_genes">select_genes</a></code></li>
<li><code><a title="knemap_functions.sort_fingerprint_by_key" href="#knemap_functions.sort_fingerprint_by_key">sort_fingerprint_by_key</a></code></li>
<li><code><a title="knemap_functions.update_dataframe_indexes" href="#knemap_functions.update_dataframe_indexes">update_dataframe_indexes</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>